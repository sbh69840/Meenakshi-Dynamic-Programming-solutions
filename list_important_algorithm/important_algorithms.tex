\documentclass[12pt]{article}
\usepackage{amsmath, amssymb, amsthm, amsfonts}
\usepackage{fullpage}
\usepackage{times}
\usepackage{tikz}
\usepackage{caption}
\usetikzlibrary{arrows}
\usepackage{verbatim}
\usepackage{array}
%\setlength{\extrarowheight}{1pt}
\usepackage{booktabs} %for top, middle and bottomline
\usepackage{bigstrut}
\usepackage{tcolorbox}
\setlength\bigstrutjot{3pt}
\usepackage{verbatim}
\usepackage{mathtools}


\usepackage{graphicx}


\usepackage[colorlinks = true,
linkcolor = red,
urlcolor  = red,
citecolor = red,
anchorcolor = red]{hyperref}
\usepackage[display]{texpower}
%\usepackage[screen,nopanel]{pdfscreen}
%\usepackage{booktabs}
\usepackage{lmodern}
\makeatletter
\newlength\mylena
\newlength\mylenb
\newcommand\mystrut[1][2]{%
	\setlength\mylena{#1\ht\@arstrutbox}%
	\setlength\mylenb{#1\dp\@arstrutbox}%
	\rule[\mylenb]{0pt}{\mylena}}
\makeatother

\newtcolorbox{mybox}[3][]
{
	colframe = #2!25,
	colback  = #2!10,
	coltitle = #2!20!black,
	title    = #3,
	#1,
}

\definecolor{grannysmithapple}{rgb}{0.66, 0.89, 0.63}
\definecolor{goldenyellow}{rgb}{1.0, 0.87, 0.0}
\definecolor{electricindigo}{rgb}{0.44, 0.0, 1.0}

% You can add more of these if it is helpful.
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\renewcommand{\qed}{\hfill $\framebox(6,6){}$}
\newtheorem*{prob*}{Problem statement}
\newtheorem{prob}{Problem statement:}[section]
\newtheorem{ques}{Question:}[section]
\newtheorem{ex}{EXAMPLE:}[section]
\newcommand*\xor{\mathbin{\oplus}}
\newcommand{\dint}{\displaystyle\int}
%\newcommand{\dfrac}{\displaystyle\frac}
\newtheorem{remark}{Remark}
\definecolor{agreen}{RGB}{102,102,102}
% Use the proof environment when the proof immediately follows the corresponding
% theorem or lemma.
\renewenvironment{proof}{\par{\noindent \bf Proof:}}{\qed \par}

% Use the proofof environment when the proof appears later.
\newenvironment{proofof}[1]{\par{\noindent \bf Proof of #1:}}{\qed\par}

% Use the proofsketch environment for less formal proof ideas.
\newenvironment{proofsketch}{\par{\noindent \bf Proof Sketch:}}{\qed\par}
\setlength{\parindent}{0cm}

% CHANGE THESE DEFINITIONS AS APPROPRIATE:
\def \scribe {Shivaraj B H} % Change this to your names
\def \lecturer {} % Change this only if there is a guest lecturer
\def \lecturedate {}  % Change this to the date of class
\def \lecturenumber {} % Change this to the number of the class
\def \lecturetitle {} % Change this too
\begin{document}
	\title{
		\fontsize{16}{24}\bfseries
		\makebox[\textwidth][s]{
			\makebox[-10pt][l]{
				}
			\hfill
			\begin{tabular}[b]{@{}c@{}}
			    Algo Bucket
			\end{tabular}%
			\hfill
		}
	-Shivaraj B H
	}
	\date{\today}
	\maketitle



	
	\begin{mybox}{goldenyellow}{}		
		Here I will be listing all the important algorithm's that you have to remember before going to any interview or coding competitions. (Not necessary that I mention every single one of them)
	\end{mybox}


			
			
\begin{mybox}{electricindigo}{}
	\textbf{Solution :} 
	\begin{itemize}
		\item[\textbf{1}] Kadane's algorithm (Effeicient algorithm for maximum subarray sum. It is based on the idea that at any point in the array we can decide whether we have to add the current element to the preivous sum or start fresh from that point.)
		\item[\textbf{2}] Johnson and Trotter algorithm (Permutations of a string using mobile integers)
		\item[\textbf{3}] Euclidean algorithm (To find GCD) 
		\item[\textbf{4}] \href{https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm}{Extended Euclidean algorithm} (Find coefficients of Bezout's identity eg: find x,y in ax+by=gcd(a,b))
		\item[\textbf{5}] Matrix exponentiation (To find solutions that consists of finding something similar to fibonacci numbers, (Where you add previous numbers (can be previous 2,3..n) to get current number))
		\item[\textbf{5}] Partition problem (To find ways to split an array in such a way that the left sum and right sum about that point becomes minimum. There is also a DP approach to find the minimum difference but I haven't been able to figure out the maximum sum (out of left and right sum) that causes the difference to be minimum. I have only written down the recursive approach.)
		\item[\textbf{6}] Some simple yet efficient one liners (element swap with XOR, powers of 2 using left shift)
		\item[\textbf{7}] Important DSA libraries in python (set(Hashing)))
		
		
		
	\end{itemize}
	

\end{mybox}
\begin{mybox}{electricindigo}{}
	\begin{itemize}
		\item[\textbf{8}] \href{https://www.geeksforgeeks.org/longest-consecutive-subsequence/}{Longest Consecutive Subsequence} (O(n) solution using hashing)
		\item[\textbf{9}] Sum of all subarrays (Two approaches : One using $2^{n-1}.sum(array)$ and another using the indexes of the elements and it's value.)
		\item[\textbf{10}] \href{http://www.jekyll.math.byuh.edu/courses/m321/handouts/gammaproperties.pdf}{Properties of Gamma function} (For positve real numbers, negative real numbers)
		\item[\textbf{11}] Calculate $n \choose k$ for large values using modulo of $10^9+7$ (Prime number) for large values of n and r (This can be used to find the number of ways to move from (0,0) to (n,n) using the formula $2(n-1) \choose (n-1)$. The basic idea is to find the numerator of combinations and then the modular inverse of the factorial part in the denominator $(n-r)!(r)!$, finally multiply the inverse with the numerator factorial value $(n)!$. Print the modulo of the result.)
		\item[\textbf{12}] Fold a paper of dimensions $h\;,\;w$ to dimensions $h_1\;,\;w_1$ (The illustration to reach to the solution for input length reaching upto $10^{15}$ has been mentioned in the code segment. The algorithm takes on an average $4.23\;{\mu}s$, for h=10,w=20,$h_1$=3,$w_1$=2 and $4.27\;{\mu}s$ for h=$10^5$,w=$20^5$,$h_1$=$3$,$w_1$=2, which is O(1) (If you \href{https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation}{look at the algorithm} used to compute the log base 2, then you will be convinced that it is not O(1) but if you consider the case above there is no such drastic increase in time and hence you can think of the algorithm to be psuedo constant) because log function is approximately a constant time operation.)
		\item[\textbf{13}] Karatsuba algorithm for multiplying n-bit numbers, Strassen algorithm for multiplying nxn matrices, change loop order to multiply two matrices (Right utilisation of cache).
		\item[\textbf{14}] Divide and conquer algorithms.
		\item[\textbf{15}] Number of ways to fill 1 and 2 in a n length tray is the nth fibonacci number, where n is the length of the array. (It is a music theory application to find number of ways to fill long and short syllables, where 1 is short and 2 is long.)
		\item[\textbf{15}] Longest monotonically increasing, bitonic sequences. (For LMI, the algorithm I have come up with is a recursive one and it takes less than $O(2^N)$, whereas it would have taken $O(2^{N}+N)$ to generate all subsequences and then find for the longest and also more auxillary space because we will be storing the subsequences. (Considering you are generating subsequence using recursion itself, which is obsolete.) )
	\end{itemize}
\end{mybox}
\begin{mybox}{electricindigo}{}
	\begin{itemize}
		\item[\textbf{16}] \href{https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/}{Longest Increasing Subsequence} O(NlogN) solution. I had implemented a recursive approach which was better (Check the code snippet for the code.) than the backtracking recursive approach given \href{https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/}{here}.
		\item[\textbf{17}] Quick sort : O(nlogn) time complexity and O(logn) space complexity. Radix sort : O(nlogU) time complexity (Where U is the largest element of the array) and O(logn) auxilary space. Heap sort : O(nlogn) time complexity and O(1) auxilary space.
		\item[\textbf{18}] Printing permutations of a string with repetitions allowed. To print permutations of a string we use backtracking (Generally), although we have a better approach as mentioned in $(\textbf{2})$. Using the backtracking approach we only have to edit how many iterations the for loop runs, to print the permutations with repetition.
	\end{itemize}
	
\end{mybox}

	

		
		

\end{document} 
